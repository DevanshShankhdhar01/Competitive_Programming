#include <iostream>
using namespace std;
#define int long long 
int32_t main() {
    int t;
    cin>>t;
    while(t--){
        
    }
}

//___________PRIME NUMBERS UPTO 1e5______________________________________________________________________________



const long long N=1e5+1;
vector<int>generate_primes(){
    vector<int>primes;
    vector<bool>a(N+1,true);
    a[1]=false;a[0]=false;
    for(int i=2;i<N;i++){
        if(!a[i]){
            continue;
        }
        primes.push_back(i);
        for(int j=1ll*i*i;j<=N;j+=i){
            a[j]=false;
        }
    }
    return primes;
}


//___________________SPF(Smallest prime factor)_______________________________________________________________

//Used to easily generate the factors of any number.

// Say i need factores of 36. I ask spf of 36. it is 2. so 36/=2 gives 18. now spf of 18 will give 2 and num becomes 9. now spf of 9 is 3 and 
//num becomes 3. now spf of 3 is 3 and num becomes 1. STOP.
// Thus we got all prime factors of number 36 i.e 2x2x3x3.


const int MAXN=1e6+5;
int spf[MAXN];

void pre(){
    for(int i=0;i<=MAXN;i++){
        spf[i]=i;
    }
    for(int i=2;i<=MAXN;i++){
        if(spf[i]==i){
            for(int j=1ll*i*i;j<=MAXN;j+=i){
                if(spf[j]==j){
                    spf[j]=i;
                }
            }
        }
    }
}

// inside main logic

while(x!=1){
    v.pb(spf[x]);
    x/=spf[x];
}




//_____________CALCULATING LOG(N)______________________________________________________________________________________



int calclog(int n){
    int cnt=0;
    while(n>0){
        cnt++;
        n=n>>1;
    }
    return cnt; // this will return 1 greater than the log i.e the farthest set bit
}

//______________CALCULATING POWER (MODULAR EXPONENTIATION)______________________________________________________________________________________





#define int long long 

const int mod = 1e9 + 7;

int power(int base, int exp, int mod) {
    int result = 1;
    while (exp > 0) {
        if (exp % 2 == 1) {  // If exponent is odd, multiply base with result
            result = (result * base) % mod;
        }
        base = (base * base) % mod;  // Square the base
        exp /= 2;  // Reduce exponent by half
    }
    return result;
}

// (a-b)%mod = ((a-b)%mod+mod)%mod


// Function to calculate (a / b) % mod
int mod_divide(int a, int b) {
    int b_inv = power(b, mod - 2, mod);  // Compute b^(-1) using Fermat's theorem
    return (a * b_inv) % mod;
}

//_____________________FACTORIALS_ AND NCR________________________________________________________________________________________



const int mod = 1e9 + 7;
const int MAXN = 1e5 + 5; // Adjust based on max value

vector<int> fact(MAXN), inv_fact(MAXN);

// Binary exponentiation: a^b % mod
int power(int a, int b) {
    int res = 1;
    a %= mod;
    while (b > 0) {
        if (b & 1) res = (res * a) % mod;
        a = (a * a) % mod;
        b >>= 1;
    }
    return res;
}

// Precompute factorials and inverse factorials
void precompute_factorials() {
    fact[0] = 1;
    for (int i = 1; i < MAXN; i++) {
        fact[i] = (fact[i - 1] * i) % mod;
    }

    inv_fact[MAXN - 1] = power(fact[MAXN - 1], mod - 2); // Fermat's Little Theorem
    for (int i = MAXN - 2; i >= 0; i--) {
        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % mod;
    }
}

//  Reusable function to compute nCr % mod
int nCr(int n, int r) {
    if (r < 0 || r > n) return 0;
    return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod;
}


//_____________Leftmost set bit____________________________________________________________________________________________

int log2_floor(int x) {
    return 31 - __builtin_clz(x);
}
// To calculte the highest power of 2<=x i.e it return the highest value of p such that (2^p <= x)

//_____________________Checking if n is prime or not(Miller Rabin Test)_____________________________________________________

using u64 = uint64_t;
using u128 = __uint128_t;

u64 binpower(u64 base, u64 e, u64 mod) {
    u64 result = 1;
    base %= mod;
    while (e) {
        if (e & 1)
            result = (u128)result * base % mod;
        base = (u128)base * base % mod;
        e >>= 1;
    }
    return result;
}

bool check_composite(u64 n, u64 a, u64 d, int s) {
    u64 x = binpower(a, d, n);
    if (x == 1 || x == n - 1)
        return false;
    for (int r = 1; r < s; r++) {
        x = (u128)x * x % n;
        if (x == n - 1)
            return false;
    }
    return true;
};


bool MillerRabin(u64 n) { // returns true if n is prime, else returns false.
    if (n < 2)
        return false;

    int r = 0;
    u64 d = n - 1;
    while ((d & 1) == 0) {
        d >>= 1;
        r++;
    }

    for (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {
        if (n == a)
            return true;
        if (check_composite(n, a, d, r))
            return false;
    }
    return true;
}

-----------------------------------------------Calculating nCr when n is upto 1e9 and r is upto 1e5-----------------------------------------


// fast exponentiation for modular inverse
int mod_pow(int base, int exp) {
    int res = 1;
    base %= mod;
    while (exp > 0) {
        if (exp & 1) res = (res * base) % mod;
        base = (base * base) % mod;
        exp >>= 1;
    }
    return res;
}

// computes nCr % mod for n up to 1e9, r up to 1e5, mod prime
int nCr(int n, int r) {
    if (r < 0 || r > n) return 0;
    if (r > n - r) r = n - r;  // symmetry nCr = nC(n-r)

    int numerator = 1, denominator = 1;
    for (int i = 0; i < r; ++i) {
        numerator = (numerator * ((n - i) % mod)) % mod;
        denominator = (denominator * (i + 1)) % mod;
    }

    // modular inverse of denominator
    int denom_inv = mod_pow(denominator, mod - 2);
    return (numerator * denom_inv) % mod;
}
